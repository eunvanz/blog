<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>방구석엔지니어</title>
    <description>밥값하는 그날까지, 삽질은 계속된다.
</description>
    <link>https://eunvanz.github.io/</link>
    <atom:link href="https://eunvanz.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 07 Jun 2018 19:28:24 +0900</pubDate>
    <lastBuildDate>Thu, 07 Jun 2018 19:28:24 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>[React] create-react-app으로 프로젝트 시작하기</title>
        <description>&lt;h1 id=&quot;create-react-app-&quot;&gt;create-react-app 이란?&lt;/h1&gt;
&lt;p&gt;create-react-app은 페이스북에서 만든 react 웹 개발용 boilerplate이다. create-react-app이 나오기 전 까지는&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;직접 모든 환경을 설정하거나,&lt;/li&gt;
  &lt;li&gt;남이 만든 boilerplate를 사용&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;했어야 했다. react는 es6 버전의 javascript로 작성하는 것이 일반화 되어있기 때문에 &lt;a href=&quot;https://webpack.js.org&quot;&gt;webpack&lt;/a&gt;이라는 모듈번들러로 컴파일 및 빌드 하는 것이 필수라 이 환경을 세팅해줘야한다. 즉, webpack도 공부해야 한다는 의미인데, 이게 쉽지가 않다. (react 공부하기에도 바쁘다.) 그래서 2번 방법을 주로 사용하곤 했는데, 개인이 만든 bolierplate이기 때문에 지속적 업데이트가 되지 않아 react 버전이 상승하면 익숙했던 bolierplate는 쓰지 못하게 되고, 새로운 bolierplate를 찾아야만 했다.&lt;/p&gt;

&lt;p&gt;create-react-app은 페이스북에서 만들고 지속적으로 업데이트 되는 공식적인 boilerplate이기 때문에 위와 같은 걱정이 없어졌다. 이 포스팅에서는 create-react-app을 통해서 간단한 TODO 웹을 만들어 보도록 하겠다.&lt;/p&gt;

&lt;h1 id=&quot;create-react-app--1&quot;&gt;create-react-app 설치&lt;/h1&gt;
&lt;p&gt;우선 npm 최신버전이 설치되어있어야 한다. 프로젝트 폴더를 생성하고자 하는 폴더로 가서 아래와 같이 명령어를 입력하자. npx는 npm 패키지를 로컬에 글로벌로 설치하지 않고 바로 일회성으로 실행할 수 있게 해주는 도구이다. npm 5.2.0 버전 이후부터 기본으로 제공된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npx create-react-app react-todo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;npx가 실행이 안되는 구버전이라면 아래와 같이 해야한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install -g create-react-app
create-react-app react-todo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;설치가 완료되면 하위에 &lt;code class=&quot;highlighter-rouge&quot;&gt;react-todo&lt;/code&gt; 라는 폴더가 생성되어 있다. 폴더 이동 후 프로젝트를 로컬에서 실행해볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd react-todo
npm start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;실행을 하면 브라우저가 실행되면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost:3000&lt;/code&gt;포트에 프로젝트가 떠 있는 것을 확인해볼 수 있다. (3000번 포트를 이미 사용 중이라면 3001, 3002, …와 같이 증가된 포트에 뜬다.)&lt;/p&gt;

&lt;h1 id=&quot;create-react-app--&quot;&gt;create-react-app 프로젝트의 구조&lt;/h1&gt;
&lt;p&gt;폴더는 아래와 같이 구성되어있다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;react-todo/
  README.md
  node_modules/
  package.json
  public/
    index.html
    favicon.ico
  src/
    App.css
    App.js
    App.test.js
    index.css
    index.js
    logo.svg
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;src 폴더에 우리가 직접 작성할 소스코드 파일이 들어가고, public 폴더에 static 자원이 위치한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;public/index.html&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;src/index.js&lt;/code&gt;는 엔트리 포인트가 되는 소스로, 파일이름이 변경되면 create-react-app은 작동하지 않으므로 주의한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;react-todo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0.1.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;private&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;dependencies&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;react&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^16.4.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;react-dom&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^16.4.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;react-scripts&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1.1.4&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;scripts&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;start&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;react-scripts start&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;build&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;react-scripts build&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;react-scripts test --env=jsdom&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;eject&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;react-scripts eject&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;파일을 얼여보면 이상하리 만큼 단순한 것을 확인할 수 있다. dependency가 3개 밖에 없고, devDependency도 없다. 하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;node_modules/&lt;/code&gt;폴더를 보면 알 수 있듯이, 내부적으로는 무수히 많은 dependency가 존재한다. 이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;create-react-app&lt;/code&gt;의 특징인데, 모든 설정들이 캡슐화 되어있다. 사용자로 하여금 설정들을 건들지 못하도록 실제 &lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;을 숨겨두고, &lt;code class=&quot;highlighter-rouge&quot;&gt;webpack&lt;/code&gt;설정과 관련된 부분들도 모두 숨겨두었다. 한마디로 개발자들이 소스코드에만 집중할 수 있도록 배려해 놓았다. &lt;code class=&quot;highlighter-rouge&quot;&gt;scripts&lt;/code&gt;설정에 보면 사용할 수 있는 명령어 중에 &lt;code class=&quot;highlighter-rouge&quot;&gt;eject&lt;/code&gt;라는 명령어를 통해 이러한 봉인을 해제할 수 있으나, 이 포스팅에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;create-react-app&lt;/code&gt;의 의도대로 소스코드에만 집중해보도록 하겠다.&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;소스코드 작성하기&lt;/h1&gt;
&lt;h2 id=&quot;section-1&quot;&gt;기존 소스코드 분석&lt;/h2&gt;
&lt;p&gt;엔트리 포인트인 &lt;code class=&quot;highlighter-rouge&quot;&gt;src/index.js&lt;/code&gt;파일을 열어보자.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import registerServiceWorker from './registerServiceWorker';

ReactDOM.render(&amp;lt;App /&amp;gt;, document.getElementById('root'));
registerServiceWorker();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;코드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;javascript ES6&lt;/code&gt; 버전으로 작성되어 있고, &lt;code class=&quot;highlighter-rouge&quot;&gt;jsx&lt;/code&gt;문법도 섞여있다. 이 문법들에 대해 익숙하지 않다면 &lt;a href=&quot;https://jsdev.kr/t/es6/2944&quot;&gt;이곳&lt;/a&gt;과 &lt;a href=&quot;https://velopert.com/867&quot;&gt;이곳&lt;/a&gt;을 참고하자. &lt;code class=&quot;highlighter-rouge&quot;&gt;ES6&lt;/code&gt;문법은 익숙해지면 꽤나 편하게 사용할 수 있고, &lt;code class=&quot;highlighter-rouge&quot;&gt;jsx&lt;/code&gt;문법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;html&lt;/code&gt;에 익숙하다면 그리 어렵지 않게 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import React from 'react';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jsx&lt;/code&gt;문법을 사용하기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;react&lt;/code&gt;모듈을 import 해야한다. 모든 react 컴포넌트에 필수적인 코드이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import ReactDOM from 'react-dom';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;react-dom&lt;/code&gt;모듈은 react 앱을 최초 렌더링 하기위해 엔트리 포인트에서 쓰인다. 브라우저 뿐만 아니라 서버사이드용 랜더링 메소드를 지원한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import './index.css';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;css파일을 import 구문으로 가져오고 있다. 이는 webpack의 &lt;a href=&quot;https://github.com/webpack-contrib/css-loader&quot;&gt;css-loader&lt;/a&gt;를 활용한 것인데, &lt;code class=&quot;highlighter-rouge&quot;&gt;create-react-app&lt;/code&gt;에서 기본적으로 세팅이 되어있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import App from './App';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;App&lt;/code&gt;이라는 react 컴포넌트를 가져오는 코드이다. 컴포넌트는 react 웹에서 기본적인 화면을 구성하는 단위이다. 예를들어, 회원 가입 화면에서 button, input, textarea와 같은 것들이 컴포넌트이고, 이러한 컴포넌트들이 구성한 화면 조차도 하나의 컴포넌트이다. react는 이러한 컴포넌트들을 만들고, 조립하는 것을 용이하게 해줌으로써 개발에 편의성을 제공한다. 컴포넌트에 대해서는 뒤에서 더 자세히 설명하겠다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import registerServiceWorker from './registerServiceWorker';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API&quot;&gt;service worker&lt;/a&gt;란 네트웍이 느리거나 오프라인인 상태에서도 온라인 인것 처럼 리소스들을 캐싱해서 보여주는 모듈을 뜻한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;create-react-app&lt;/code&gt;에서는 기본으로 구현하여 소스코드에 포함되어있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, document.getElementById('root'));
registerServiceWorker();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;라는 id를 가진 태그를 찾아서 그 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;App&lt;/code&gt;컴포넌트를 렌더링시킨다. 이곳이 우리가 만드는 react 웹의 엔트리 포인트인데, 껍데기가 되는 html 파일은 &lt;code class=&quot;highlighter-rouge&quot;&gt;public/index.html&lt;/code&gt;파일이 된다. 이 파일을 열어보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;라는 id를 가진 &lt;code class=&quot;highlighter-rouge&quot;&gt;div&lt;/code&gt;태그가 존재함을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;그렇다면 우리가 소스코드를 작성해야 하는 파일은? &lt;code class=&quot;highlighter-rouge&quot;&gt;App.js&lt;/code&gt;파일이 된다. 파일을 열어보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  render() {
    return (
      &amp;lt;div className=&quot;App&quot;&amp;gt;
        &amp;lt;header className=&quot;App-header&quot;&amp;gt;
          &amp;lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&amp;gt;
          &amp;lt;h1 className=&quot;App-title&quot;&amp;gt;Welcome to React&amp;lt;/h1&amp;gt;
        &amp;lt;/header&amp;gt;
        &amp;lt;p className=&quot;App-intro&quot;&amp;gt;
          To get started, edit &amp;lt;code&amp;gt;src/App.js&amp;lt;/code&amp;gt; and save to reload.
        &amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export default App;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모든 react 컴포넌트들은 react 모듈의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Component&lt;/code&gt;클래스를 상속받는다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Component&lt;/code&gt;는 ui를 구성하는 엘리먼트들을 독립적이고 재사용 가능하게 만드는 추상 클래스라고 생각하면 된다. 미리 정의해 둔 메소드들이 있고, 그 메소드들을 override 해서 컴포넌트들을 구현하는데, 그 중에서 화면을 그려주는 &lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt; 메소드는 필수적으로 정의해야 한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt; 메소드는 반드시 jsx 문법으로 작성한 하나의 엘리먼트를 리턴한다.&lt;/p&gt;

&lt;h2 id=&quot;state-&quot;&gt;state 만들기&lt;/h2&gt;
&lt;p&gt;TODO 웹을 만들기에 앞서서, react Component에서 빠질 수 없는 개념인 &lt;code class=&quot;highlighter-rouge&quot;&gt;state&lt;/code&gt;에 대해 알고 넘어가고자 한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;state&lt;/code&gt;는 컴포넌트의 스코프 안의 지역변수라고 할 수 있다. 이 state가 변경되면 이 state를 참조하고 있는 컴포넌트의 다른 부분들도 영향을 받아 업데이트 된다. 우선 state를 선언부터 해보겠다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;...

class App extends Component {
  constructor (props) {
    super(props)
    this.state = {
      todoItems: [] // todo 아이템이 들어갈 배열 선언
    }
  }
  render() {
    ...
  }
}

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;render 함수 위에 constructor를 선언하고, constructor 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;this.state&lt;/code&gt;를 선언했다. state는 기본적으로 Object의 형태로 선언한다. 여기에서는 todo 아이템이 들어갈 배열을 선언했다. 이 state에 &lt;code class=&quot;highlighter-rouge&quot;&gt;todo&lt;/code&gt; 객체들을 넣을 생각이다.&lt;/p&gt;

&lt;h2 id=&quot;render--&quot;&gt;render 함수 구현하기&lt;/h2&gt;
&lt;p&gt;render 함수는 화면에 그려지는 엘리먼트들을 jsx 문법으로 리턴한다. 우선 할 일을 등록하는 양식이 필요할 것 같다. 간단하게 할 일을 입력할 수 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;input&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt;을 만들어보자. 스타일도 포기할 수 없으니 css는 &lt;a href=&quot;https://getbootstrap.com&quot;&gt;bootstrap&lt;/a&gt;을 사용하도록 해보자.&lt;/p&gt;

&lt;h3 id=&quot;publicindexhtml&quot;&gt;public/index.html&lt;/h3&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    ...
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;integrity=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;crossorigin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;anonymous&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    ...
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  ...
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public/index.html&lt;/code&gt;에 bootstrap css를 추가한다.&lt;/p&gt;

&lt;h3 id=&quot;srcappjs&quot;&gt;src/App.js&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;...

let todoId = 0 // todo 아이템의 id를 증가시키며 저장하는 변수

class App extends Component {
  constructor (props) {
    super(props)
    this.state = {
      todoItems: [],
      todoInput: '' // 새 할 일 input의 value를 저장하는 state
    }
    this._handleOnClickAddItem = this._handleOnClickAddItem.bind(this)
    this._handleOnChangeTodoInput = this._handleOnChangeTodoInput.bind(this)
  }

  _handleOnClickAddItem () {
    const { todoInput, todoItems } = this.state
    if (todoInput.length === 0) return alert('내용을 입력해주세요.')
    const todoItem = {
      id: todoId++,
      title: todoInput,
      isCompleted: false
    }
    const newTodoItems = todoItems.slice(0)
    newTodoItems.push(todoItem)
    this.setState({ todoItems: newTodoItems, todoInput: '' })
  }

  _handleOnChangeTodoInput (e) {
    this.setState({ todoInput: e.target.value })
  }

  render () {
    return (
      &amp;lt;div className='container' style={{ maxWidth: 600, padding: '20px 0' }}&amp;gt;
        &amp;lt;div className='row'&amp;gt;
          &amp;lt;div className='col text-center'&amp;gt;
            &amp;lt;div className='input-group'&amp;gt;
              &amp;lt;input
                type='text'
                className='form-control'
                placeholder='새로운 할 일을 입력해주세요.'
                value={this.state.todoInput}
                onChange={this._handleOnChangeTodoInput}
                onKeyDown={e =&amp;gt; e.keyCode === 13 ? this._handleOnClickAddItem() : null}
              /&amp;gt;
              &amp;lt;div className='input-group-append'&amp;gt;
                &amp;lt;button
                  className='btn btn-outline-secondary'
                  onClick={this._handleOnClickAddItem}
                &amp;gt;
                  등록
                &amp;lt;/button&amp;gt;
              &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }
}

export default App;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;새 할일을 등록할 폼을 작성해보았다. 이 코드만으로도 리액트의 여러가지 문법들과 보편적인 구조를 확인해볼 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;스타일링 : jsx 문법에서의 클래스 명은 &lt;code class=&quot;highlighter-rouge&quot;&gt;className&lt;/code&gt;이라는 속성을 사용한다. es6의 &lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;지정자와 겹치기 때문이다. 따라서 기존 레가시 html을 복사 붙여넣기 할 경우 class 속성이 그대로 남아있으면 스타일이 먹지 않으므로 주의해야 한다. 인라인 스타일의 경우에는 javascript object 형태로 입력해야 한다. jsx 문법에서 javascript를 삽입하기 위해서는 중괄호 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;를 사용하는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;style&lt;/code&gt;속성 내에 javascript object를 넣다 보니 &lt;code class=&quot;highlighter-rouge&quot;&gt;style={{ maxWidth: 600, padding: '20px 0' }}&lt;/code&gt;과 같은 형태가 된다. css 문법의 케밥케이스를 카멜케이스로 옮기는 방식으로 키를 지정하고, 값은 css 문법 그대로 string 타입으로 넣거나, number타입으로 넣어도 된다. number타입일 경우에 단위는 픽셀로 인식이 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;폼 엘리먼트 : 리액트 컴포넌트는 기본적으로 state와 props의 변화에 따라 새롭게 화면을 랜더링을 한다. (메모리에서 DOM을 비교하여 변경이 되는DOM만 새로 렌더링) &lt;code class=&quot;highlighter-rouge&quot;&gt;input&lt;/code&gt;은 사용자의 키보드 입력이 들어올 때 마다 화면을 새로 렌더링해줘야 하는데, 이를 위해 컴포넌트의 state를 이용한다. 위 예제에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;todoInput&lt;/code&gt;이라는 state를 만들어주었고, 초기값을 &lt;code class=&quot;highlighter-rouge&quot;&gt;''&lt;/code&gt;로 설정했다. 그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;input&lt;/code&gt;태그의 &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;속성에 &lt;code class=&quot;highlighter-rouge&quot;&gt;todoInput&lt;/code&gt;을 할당해주었다. 또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;input&lt;/code&gt;태그의 &lt;code class=&quot;highlighter-rouge&quot;&gt;onChange&lt;/code&gt;이벤트에 &lt;code class=&quot;highlighter-rouge&quot;&gt;this._handleOnChangeTodoInput&lt;/code&gt;메소드를 할당하여 키보드 입력 시에 &lt;code class=&quot;highlighter-rouge&quot;&gt;todoInput&lt;/code&gt; state를 변경하도록 했다. 리액트에서 하나의 &lt;code class=&quot;highlighter-rouge&quot;&gt;input&lt;/code&gt;태그가 작동하려면 이러한 일련의 과정을 거쳐야한다. (조금 복잡하다고 생각할 수도 있지만 간편하게 사용할 수 있는 폼 컨트롤과 관련된 라이브러리들을 사용하면 되므로 너무 걱정하지 말자. 원리를 이해하기 위한 과정일 뿐이다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이벤트바인딩 : &lt;code class=&quot;highlighter-rouge&quot;&gt;input&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;onChange&lt;/code&gt;속성을 이용하여 DOM과 이벤트를 바인딩한 것 처럼, jsx 태그에 &lt;code class=&quot;highlighter-rouge&quot;&gt;on****&lt;/code&gt;와 같은 속성을 넣어주는 것으로 이벤트와 함수를 바인딩시킬 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;등록&lt;/code&gt;버튼에 &lt;code class=&quot;highlighter-rouge&quot;&gt;onClick&lt;/code&gt;속성을 넣어주어 버튼 클릭 시에 새로운 할 일을 등록하는 함수를 실행한다. 그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;input&lt;/code&gt;태그에 &lt;code class=&quot;highlighter-rouge&quot;&gt;onKeyDown&lt;/code&gt;속성을 넣어주어 키보드 입력이 엔터키일경우 같은 기능을 수행하도록 했다. class의 멤버 함수를 선언할 때 함수 안에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;를 사용하는 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;this._handleOnClickAddItem = this._handleOnClickAddItem.bind(this)&lt;/code&gt;와 같이 함수에 인스턴스를 바인딩 해주는 것을 잊지말자. (해줘야 하는 경우와 안해도 되는 경우가 있는데, 자세한 설명은 &lt;a href=&quot;https://medium.freecodecamp.org/react-binding-patterns-5-approaches-for-handling-this-92c651b5af56&quot;&gt;이곳&lt;/a&gt;을 참고하자.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;
import React, { Component } from 'react';

let todoId = 0 // todo 아이템의 id를 증가시키며 저장하는 변수

class App extends Component {
  constructor (props) {
    super(props)
    this.state = {
      todoItems: [],
      todoInput: ''
    }
    this._handleOnClickAddItem = this._handleOnClickAddItem.bind(this)
    this._handleOnChangeTodoInput = this._handleOnChangeTodoInput.bind(this)
    this._handleOnClickToggleState = this._handleOnClickToggleState.bind(this)
    this._handleOnClickRemove = this._handleOnClickRemove.bind(this)
  }

  _handleOnClickAddItem () {
    const { todoInput, todoItems } = this.state
    if (todoInput.length === 0) return alert('내용을 입력해주세요.')
    const todoItem = {
      id: todoId++,
      title: todoInput,
      isCompleted: false
    }
    const newTodoItems = todoItems.slice(0)
    newTodoItems.push(todoItem)
    this.setState({ todoItems: newTodoItems, todoInput: '' })
  }

  _handleOnChangeTodoInput (e) {
    this.setState({ todoInput: e.target.value })
  }

  _handleOnClickToggleState (index) { // index에 해당하는 아이템의 isCompleted 를 토글한다.
    const { todoItems } = this.state
    const newTodoItems = todoItems.slice(0)
    newTodoItems[index].isCompleted = !todoItems[index].isCompleted
    this.setState({ todoItems: newTodoItems })
  }

  _handleOnClickRemove (id) {
    const { todoItems } = this.state
    const newTodoItems = todoItems.filter(item =&amp;gt; item.id !== id)
    this.setState({ todoItems: newTodoItems })
  }

  render () {
    const renderCancelButton = item =&amp;gt; (
      &amp;lt;button
        className='btn btn-danger btn-sm'
        style={{ marginLeft: 5 }}
        onClick={() =&amp;gt; this._handleOnClickRemove(item.id)}
      &amp;gt;
        삭제
      &amp;lt;/button&amp;gt;
    )
    return (
      &amp;lt;div className='container' style={{ maxWidth: 600, padding: '20px 0' }}&amp;gt;
        &amp;lt;div className='row'&amp;gt;
          &amp;lt;div className='col text-center'&amp;gt;
            &amp;lt;div className='input-group'&amp;gt;
              &amp;lt;input
                type='text'
                className='form-control'
                placeholder='새로운 할 일을 입력해주세요.'
                value={this.state.todoInput}
                onChange={this._handleOnChangeTodoInput}
                onKeyDown={e =&amp;gt; e.keyCode === 13 ? this._handleOnClickAddItem() : null}
              /&amp;gt;
              &amp;lt;div className='input-group-append'&amp;gt;
                &amp;lt;button
                  className='btn btn-outline-secondary'
                  onClick={this._handleOnClickAddItem}
                &amp;gt;
                  등록
                &amp;lt;/button&amp;gt;
              &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div className='row' style={ { marginTop: 20 } }&amp;gt;
          &amp;lt;div className='col-6'&amp;gt;
            &amp;lt;h3&amp;gt;해야할 일&amp;lt;/h3&amp;gt;
            {
              this.state.todoItems.filter(item =&amp;gt; !item.isCompleted).map(item =&amp;gt;
                &amp;lt;div key={item.id} style={{ margin: 10 }}&amp;gt;
                  &amp;lt;span style={{ marginRight: 5 }}&amp;gt;- {item.title}&amp;lt;/span&amp;gt;
                  &amp;lt;button
                    className='btn btn-success btn-sm'
                    onClick={() =&amp;gt; this._handleOnClickToggleState(item.id)}
                  &amp;gt;
                    완료
                  &amp;lt;/button&amp;gt;
                  {renderCancelButton(item)}
                &amp;lt;/div&amp;gt;
              )
            }
          &amp;lt;/div&amp;gt;
          &amp;lt;div className='col-6'&amp;gt;
            &amp;lt;h3&amp;gt;완료한 일&amp;lt;/h3&amp;gt;
            {
              this.state.todoItems.filter(item =&amp;gt; item.isCompleted).map(item =&amp;gt;
                &amp;lt;div key={item.id} style={{ margin: 10 }}&amp;gt;
                  &amp;lt;span style={{ marginRight: 5 }}&amp;gt;- {item.title}&amp;lt;/span&amp;gt;
                  &amp;lt;button
                    className='btn btn-warning btn-sm'
                    onClick={() =&amp;gt; this._handleOnClickToggleState(item.id)}
                  &amp;gt;
                    취소
                  &amp;lt;/button&amp;gt;
                  {renderCancelButton(item)}
                &amp;lt;/div&amp;gt;
              )
            }
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export default App;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;등록된 최종적인 소스이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt;메소드 안에서 중복되는 엘리먼트들은 &lt;code class=&quot;highlighter-rouge&quot;&gt;renderCancelButton&lt;/code&gt;함수처럼 함수로 지정하여 사용할 수도 있다. 하지만 이 방법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt;함수가 호출될 때 마다(화면을 다시 렌더링 할 때 마다) 쓸 데 없이 함수를 다시 선언하는 과정을 거치니 앞으로는 멤버함수(&lt;code class=&quot;highlighter-rouge&quot;&gt;this._renderCancelButton&lt;/code&gt;와 같은 방식)로 선언해주도록 하자. 아래와 같이 잘 작동되면 성공!!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/create-react-app_TODO_1.gif&quot; alt=&quot;실행화면&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 포스팅에서는 내부 엘리먼트들을 리액트 컴포넌트로 분리해보도록 하겠다.
전체 소스는 &lt;a href=&quot;https://github.com/eunvanz/create-react-app-todo-1&quot;&gt;이곳&lt;/a&gt;에 공유되어있다.&lt;/p&gt;
</description>
        <pubDate>Tue, 05 Jun 2018 12:44:06 +0900</pubDate>
        <link>https://eunvanz.github.io/react/2018/06/05/React-create-react-app%EC%9C%BC%EB%A1%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/</link>
        <guid isPermaLink="true">https://eunvanz.github.io/react/2018/06/05/React-create-react-app%EC%9C%BC%EB%A1%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/</guid>
        
        <category>react</category>
        
        <category>create-react-app</category>
        
        
        <category>react</category>
        
      </item>
    
      <item>
        <title>[React] Higher Order Component로 form handling 관심사 분리하기</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://eunvanz.github.io/react/2017/11/05/React-Higher-Order-Component-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/&quot;&gt;지난 포스팅&lt;/a&gt;에서 Higher Order Component(이하 HOC)에 대해 간략하게나마 알아보았다. 오늘은 좀 더 심화되고 실전적인 예시를 보여주려 한다. 실제로 내가 프로젝트를 진행하면서 부딪혔던 상황에서 어떠한 방식으로 HOC를 적용하여 문제를 해결했는지 좀 더 단순화하여 소개한다.&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;문제 상황&lt;/h1&gt;
&lt;p&gt;리액트에서 기본적으로 form을 핸들링하는 패턴은 아래와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import React from 'react'

class SignUpForm extends React.Component {
  constructor (props) {
    super(props)
    this.state = {
      email: '',
      password: '',
      passwordConfirm: ''
    }
    this._handleOnChangeInput = this._handleOnChangeInput.bind(this)
  }
  _handleOnChangeInput (e) {
    const { name, value } = e.target
    this.setState({ [name]: value })
  }
  render () {
    const { email, password, passwordConfirm } = this.state
    &amp;lt;form&amp;gt;
      &amp;lt;input
        type='text'
        name='email'
        placeholder='이메일주소'
        value={email}
        onChange={this._handleOnChangeInput}
      /&amp;gt;
      &amp;lt;input
        type='password'
        name='password'
        placeholder='비밀번호'
        value={password}
        onChange={this._handleOnChangeInput}
      /&amp;gt;
      &amp;lt;input
        type='password'
        name='passwordConfirm'
        placeholder='비밀번호 확인'
        value={passwordConfirm}
        onChange={this._handleOnChangeInput}
      /&amp;gt;
      &amp;lt;button&amp;gt;Sign Up&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;form handling과 관련되지 않은 부분을 생략한다면 View의 코드는 위와 같은 형태일 것이다. 이렇게 한 페이지 작성하는 것은 별 어려움이 없으나, form 요소가 들어가는 페이지가 많을 경우에는 굉장히 귀찮은 작업이다. 때때로 노가다 작업으로 느껴진다. form 요소가 들어가게 되면 항상 공통적으로 작성되는 부분이 존재하기 때문이다. 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;constructor()&lt;/code&gt; 함수의 &lt;code class=&quot;highlighter-rouge&quot;&gt;this.state...&lt;/code&gt; 부분과, &lt;code class=&quot;highlighter-rouge&quot;&gt;_handleOnChageInput()&lt;/code&gt; 함수이다. 작업을 하다보니 아래와 같은 점에서 문제가 되었다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;this.state&lt;/code&gt;에서 form과 관련된 객체를 따로 뺄 경우, &lt;code class=&quot;highlighter-rouge&quot;&gt;_handleOnChangeInput()&lt;/code&gt; 함수 구현이 많이 귀찮아졌다. 예를들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;this.state.form&lt;/code&gt;이라는 객체를 form의 필드들과 바인딩 시킬경우, &lt;code class=&quot;highlighter-rouge&quot;&gt;this.setState({ form: Object.assign({}, this.state.form, { [name]: value })})&lt;/code&gt;와 같은 식이다. 복잡할 경우에는 &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;immutable.js&lt;/a&gt;와 같은 라이브러리를 사용해야 할 경우도 있다.&lt;/li&gt;
  &lt;li&gt;validation이 필요할 경우에 문제는 더욱 커진다. 노가다 작업이 괴롭다.&lt;/li&gt;
  &lt;li&gt;필드 수가 많은 경우 전체 코드에서 form handling에 관련된 코드가 차지하는 비중도 커진다.&lt;/li&gt;
  &lt;li&gt;Pure Component로 작성할 수 있는 간단한 컴포넌트도 state로 인해 생성자와 state를 작성해야 한다.&lt;/li&gt;
  &lt;li&gt;무엇보다 같은 패턴의 함수들이 여러 컴포넌트에 걸쳐 작성되어야 한다는게 심리적으로 납득하기 힘들다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위와 같은 이유로 인해 form handling과 관련된 관심사를 분리할 수 있는 HOC를 만들어보기로 했다.&lt;/p&gt;

&lt;h1 id=&quot;form-handling-hoc-&quot;&gt;form handling HOC 구현&lt;/h1&gt;

&lt;p&gt;만들게 될 HOC의 스펙은 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;view에 랜더링되는 form의 각 필드들과 바인딩되는 state를 가지고 있고, 이를 view에 &lt;code class=&quot;highlighter-rouge&quot;&gt;formData&lt;/code&gt;라는 prop으로 전달&lt;/li&gt;
  &lt;li&gt;view의 input의 &lt;code class=&quot;highlighter-rouge&quot;&gt;onChange&lt;/code&gt; 이벤트에 따라 HOC의 state를 변경해 줄 &lt;code class=&quot;highlighter-rouge&quot;&gt;_handleOnChangeInput&lt;/code&gt; 함수를 가지고 있고, 이를 view에 &lt;code class=&quot;highlighter-rouge&quot;&gt;onChangeInput&lt;/code&gt;이라는 prop으로 전달&lt;/li&gt;
  &lt;li&gt;HOC 생성 시 &lt;code class=&quot;highlighter-rouge&quot;&gt;formConfig&lt;/code&gt; 객체를 인자로 전달받아 state를 구성 (필드명, 초기값)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;원리만 이해할 수 있도록 아주 간단한 스펙으로 설정해보았다. 실제로는 validation 기능까지 붙여서 프로젝트에 사용하고 있다. 아래 코드가 HOC 코드이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;withFormData.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import React from 'react'
import PropTypes from 'prop-types'

export default formConfig =&amp;gt; ComposedComponent =&amp;gt; {
  class withFormData extends React.Component {
    constructor (props) {
      super(props)
      const initialState = {}
      formConfig.forEach(config =&amp;gt; {
        initialState[config.inputName] = config.defaultValue || ''
      })
      this.state = initialState
      this._handleOnChangeInput = this._handleOnChangeInput.bind(this)
    }
    _handleOnChangeInput (e) {
      const { value, name } = e.target
      this.setState({ [name]: value })
    }
    render () {
      return &amp;lt;ComposedComponent onChangeInput={this._handleOnChangeInput} formData={this.state} {...this.props} /&amp;gt;
    }
  }
  return withFormData
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래는 &lt;code class=&quot;highlighter-rouge&quot;&gt;withFormData.js&lt;/code&gt;를 사용하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;SignInView.js&lt;/code&gt;를 감싸는 &lt;code class=&quot;highlighter-rouge&quot;&gt;SignInContainer.js&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SignInContainer.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import withFormData from 'hocs/withFormData'
import SignInView from '../components/SignInView'

const formConfig = [
  {
    inputName: 'email',
    defaultValue: ''
  },
  {
    inputName: 'password',
    defaultValue: ''
  },
  {
    inputName: 'passwordConfirm',
    defaultValue: ''
  },
]

const wrappedSignInView = withFormData(formConfig)(SignInView)

export default wrappedSignInView
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이로 인해 &lt;code class=&quot;highlighter-rouge&quot;&gt;onChangeInput&lt;/code&gt;함수와 &lt;code class=&quot;highlighter-rouge&quot;&gt;formData&lt;/code&gt;라는 state가 &lt;code class=&quot;highlighter-rouge&quot;&gt;SignInView&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;props&lt;/code&gt;로 주입되었다. 이제 이 prop들을 사용하는 View를 만들면 된다. 간단하게 Pure Component로 구현해보겠다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SignInView.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import { PureComponent } from 'react'
import PropTypes from 'prop-types'

export default class SignInView extends PureComponent {
  static propTypes = {
    formData: PropTypes.object.isRequired,
    onChangeInput: PropTypes.func.isRequired
  }
  render () {
    const { formData, onChangeInput } = this.props
    return (
      &amp;lt;form&amp;gt;
        &amp;lt;input
          type='text'
          name='email'
          placeholder='이메일주소'
          value={formData.email}
          onChange={onChangeInput}
        /&amp;gt;
        &amp;lt;input
          type='password'
          name='password'
          placeholder='비밀번호'
          value={formData.password}
          onChange={onChangeInput}
        /&amp;gt;
        &amp;lt;input
          type='password'
          name='passwordConfirm'
          placeholder='비밀번호 확인'
          value={formData.passwordConfirm}
          onChange={onChangeInput}
        /&amp;gt;
        &amp;lt;button&amp;gt;Sign Up&amp;lt;/button&amp;gt;
      &amp;lt;/form&amp;gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Component대신 PureComponent를 상속하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;shouldComponentUpdate&lt;/code&gt;호출 시 props를 &lt;code class=&quot;highlighter-rouge&quot;&gt;shallowCompare&lt;/code&gt;해주는 컴포넌트를 구현하였다. 이처럼 stateless하게 컴포넌트를 구성하면 코드가 간결해진다. 또한 성능이나 side effect 측면에서도 유리하다. 실제 프로젝트에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;defaultValue&lt;/code&gt;를 redux store에서 받은 전역 props에서 받아서 설정할 수 있는 부분과, validation 설정 부분이 추가되어서 더욱 복잡해졌지만, 기본적인 골자는 이와 같다. 한 번만 잘 만들어 놓으면 어떤 컴포넌트에서라도 너무나 편리하게 사용할 수 있으니, 나만의 form handling HOC를 꼭 만들어보자.&lt;/p&gt;

</description>
        <pubDate>Mon, 12 Feb 2018 23:44:40 +0900</pubDate>
        <link>https://eunvanz.github.io/react/2018/02/12/React-Higher-Order-Component%EB%A1%9C-form-handling-%EA%B4%80%EC%8B%AC%EC%82%AC-%EB%B6%84%EB%A6%AC%ED%95%98%EA%B8%B0/</link>
        <guid isPermaLink="true">https://eunvanz.github.io/react/2018/02/12/React-Higher-Order-Component%EB%A1%9C-form-handling-%EA%B4%80%EC%8B%AC%EC%82%AC-%EB%B6%84%EB%A6%AC%ED%95%98%EA%B8%B0/</guid>
        
        <category>react</category>
        
        <category>hoc</category>
        
        
        <category>react</category>
        
      </item>
    
      <item>
        <title>[React] Higher Order Component 이해하기</title>
        <description>&lt;h1 id=&quot;higher-order-component-&quot;&gt;Higher Order Component 개요&lt;/h1&gt;
&lt;p&gt;Higher Order Component (이하 HOC)는 리액트에서 사용되는 일종의 디자인 패턴이다. HOC는 리액트 컴포넌트를 인자로 받아 리액트 컴포넌트를 반환한다. 기본적으로 아래와 같은 형태이다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;export default ComposedComponent =&amp;gt; {
  class HOC extends React.Component {
    const { ...props } = this.props
    render () {
      return &amp;lt;ComposedComponent {...props} /&amp;gt;
    }
  }
  return HOC
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드를 템플릿으로 하여 갖가지 양념을 쳐서 특정한 기능을 수행하는 컴포넌트를 생산할 수 있다. 주로, 여러 컴포넌트에 반복적으로 들어가는 코드들을 HOC에 작성하면 된다. 즉, 여러 컴포넌트들이 가지고 있는 횡단관심사(Cross-cutting concerns)들을 구현하는 컴포넌트가 HOC이다.&lt;/p&gt;

&lt;p&gt;스프링 AOP를 공부하면서 들었던 개념이 횡단관심사라는 개념인데, View에서의 횡단관심사는 감이 잘 잡히지 않는다. View에서의 횡단관심사들은 어떤것들이 있을까? 생각해보면 생각보다 많다. 그리고 실제로 작업을 하다보면 이러한 횡단관심사들이 View에서도 상당히 많다. 일단 생각나는 것을 떠올려보면,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;유저 인증 로직:&lt;/strong&gt; 사용자가 로그인 상태인지, 권한이 있는 사용자인지에 따라 페이지를 보여주거나, 로그인 페이지로 이동시키거나, 권한이 없다는 안내 메시지를 띄우는 등, 사용자 상태에 따라 분기를 시키는 유저 인증 작업을 HOC에게 위임할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Dumb와 Smart 컴포넌트 분리:&lt;/strong&gt; Redux 패턴에서 권장하는 방식인 Dumb 컴포넌트(Presentational Component)와 Smart 컴포넌트(Container Component)를 분리하는데에 사용되고 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;react-redux&lt;/code&gt;모듈에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;connect&lt;/code&gt;라는 HOC를 제공하고 있으며, 이는 Dumb 컴포넌트와 Smart 컴포넌트를 분리할 수 있게 해준다. 이로 인해 컴포넌트의 재사용성과 유지보수 용이성을 높일 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;로딩 화면 표시:&lt;/strong&gt; 화면을 띄우기위한 데이터가 로딩 중일 때 로딩 화면을 표시하고, 데이터 로딩이 완료됐을 때 인자로 받은 컴포넌트를 보여주도록 하는 로직을 HOC가 담당하게 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 것들을 쉽게 떠올릴 수 있다. 좀 더 복잡하게 사용하면 폼 데이터와 state의 바인딩 등과 같이 더욱 다양한 상황에서 사용할 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;higher-order-component--1&quot;&gt;Higher Order Component 구현&lt;/h1&gt;
&lt;p&gt;간단하게 HOC를 구현해 보는 예제이다. 사용자 로그인 상태일경우 페이지를 정상적으로 보여주고, 로그인이 돼있지 않을 경우 로그인 페이지로 이동하는 로직을 갖고 있는 HOC를 구현해보겠다.&lt;/p&gt;

&lt;p&gt;그 전에 몇 가지 가정이 필요하다. 아래는 현재 내가 실제로 진행하고 있는 프로젝트의 환경과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자가 로그인 상태일 경우에는 redux store의 state에 user라는 키값으로 user 객체가 존재&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;needAuth.js:&lt;/strong&gt; 로그인 여부에 따라 페이지 이동 처리를 하는 HOC로, 로그인 상태가 아닐 시 &lt;code class=&quot;highlighter-rouge&quot;&gt;/sign-in&lt;/code&gt; route로 이동&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;UserProfileContainer.js:&lt;/strong&gt; redux store와 뷰를 연결짓는 container 컴포넌트&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;UserProfileView.js:&lt;/strong&gt; 사용자 자신의 프로필을 조회하는 presentational 컴포넌트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;needAuth.js:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import React from 'react'
import PropTypes from 'prop-types'
import { connect } from 'react-redux'

export default ComposedComponent =&amp;gt; {
  class needAuth extends React.Component {
    componentDidMount () {
      const { user } = this.props
      if (!user) this.context.router.push('/sign-in')
    }
    render () {
      const { user, ...props } = this.props
      if (!user) return &amp;lt;div&amp;gt;로그인 처리 중...&amp;lt;/div&amp;gt;
      return &amp;lt;ComposedComponent user={user} {...props} /&amp;gt;
    }
  }
  needAuth.contextTypes = {
    router: PropTypes.object.isRequired
  }
  needAuth.propTypes = {
    user: PropTypes.object
  }
  const mapStateToProps = state =&amp;gt; {
    return {
      user: state.user
    }
  }
  return connect(mapStateToProps, null)(needAuth)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;UserProfileContainer.js:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import UserProfileView from '../components/UserProfileView'
import needAuth from 'hocs/needAuth'

export default needAuth(UserProfileView)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;UserProfileView.js:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import React from 'react'
import PropTypes from 'prop-types'

class UserProfileView extends React.Component {
  render () {
    const { user } = this.props
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;p&amp;gt;name: {user.name}&amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt;mobile: {user.mobile}&amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt;hobby: {user.hobby}&amp;lt;/p&amp;gt;
      &amp;lt;div&amp;gt;
    )
  }
}
UserProfileView.propTypes = {
  user: PropTypes.object.isRequired
}
export default UserProfileView
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 간단하게 HOC를 만들고 적용해보았다. 실제 프로젝트에 적용한 결과 아주 잘 작동한다.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Feb 2018 22:31:38 +0900</pubDate>
        <link>https://eunvanz.github.io/react/2018/02/05/React-Higher-Order-Component-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</link>
        <guid isPermaLink="true">https://eunvanz.github.io/react/2018/02/05/React-Higher-Order-Component-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</guid>
        
        <category>react</category>
        
        <category>hoc</category>
        
        
        <category>react</category>
        
      </item>
    
      <item>
        <title>ES6에서 Promise를 순차적으로 실행하기</title>
        <description>&lt;p&gt;Promise는 javascript의 비동기 호출 시 펼쳐지는 callback지옥을 해소할 수 있는 아주 유용한 ES6 객체이다. 현재 존재하는 Promise의 함수 중에서 여러 Promise 함수들을 한꺼번에 handling 할 수 있도록 해주는 함수로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.all()&lt;/code&gt;이라는 함수가 있지만, 이 함수는 Promise 함수들을 순차적으로 실행시켜 주지는 않는다.&lt;/p&gt;

&lt;p&gt;예를 들어, 정렬되어 있는 순서대로 순차적으로 DB에 입력되어야 하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;items&lt;/code&gt;라는 Object 배열이 있다. 순차적으로 DB에 입력한다는 조건을 무시한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.all()&lt;/code&gt;을 사용하여 아래와 같이 코드를 짤 수 있을 것이다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;axios&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'axios'&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;API_BASE_URL&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'./constant'&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;items&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'firstItem'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'secondItem'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'thirdItem'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'fourthItem'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;postItem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;axios&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;API_BASE_URL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/item`, item&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;promArr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;postItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;promArr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 성공 후 처리&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위 코드는 얼핏보면 정렬된 &lt;code class=&quot;highlighter-rouge&quot;&gt;items&lt;/code&gt;에 대하여 순차적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;postItem&lt;/code&gt;함수가 호출되고 db에 순차적으로 입력될 것 같지만, 각 함수들은 병렬적으로 실행되어 결국에는 뒤죽박죽으로 입력된다. 비동기이기 때문에 각 함수들이 수행되는 시간이 일정하지 않기 때문이다. 즉, 순서가 보장되지 않는다. 순서를 보장하기 위해서는 아래와 같이 코드를 고쳐야 한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;postItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;postItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;postItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;postItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 성공 후 처리&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;하지만, 이 코드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;items&lt;/code&gt;의 length가 클 경우에 사용할 수가 없다.&lt;/p&gt;

&lt;h1 id=&quot;reduce---promise--&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce()&lt;/code&gt;를 활용하여 순차적으로 Promise 함수 실행하기&lt;/h1&gt;
&lt;p&gt;이 문제는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.prototype.reduce()&lt;/code&gt;함수를 활용하면 간단히 해결 가능하다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.prototype.reduce()&lt;/code&gt;함수의 자세한 설명은 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;이곳&lt;/a&gt;을 참고하자.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prevProm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;prevProm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;postItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 성공 후 처리&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이와 같은 방법으로 아주 간단하게 순차적으로 여러 Promise 함수를 처리할 수 있다.&lt;/p&gt;

</description>
        <pubDate>Tue, 30 Jan 2018 00:18:26 +0900</pubDate>
        <link>https://eunvanz.github.io/javascript/2018/01/30/ES6%EC%97%90%EC%84%9C-Promise%EB%A5%BC-%EC%88%9C%EC%B0%A8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0/</link>
        <guid isPermaLink="true">https://eunvanz.github.io/javascript/2018/01/30/ES6%EC%97%90%EC%84%9C-Promise%EB%A5%BC-%EC%88%9C%EC%B0%A8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0/</guid>
        
        <category>javascript</category>
        
        <category>es6</category>
        
        
        <category>javascript</category>
        
      </item>
    
      <item>
        <title>GitHub 블로그에서 Jekyll 플러그인 사용하기</title>
        <description>&lt;p&gt;GitHub Pages 내부적으로 Jekyll을 사용하고 있고, 정적 페이지 생성에 있어서 Jekyll의 간편함때문에 많은 개발자들이 자신의 기술블로그로 GitHub Pages를 사용하고 있다. 하지만 GitHub에서는 보안상의 이유로 GitHub에서 기본으로 제공하고 있는 플러그인 이외의 사용자 플러그인을 지원하지 않고 있다. 그래도 외부 플러그인을 사용하는 방법이 다 있다. 그런데 ruby를 잘 모른다면 적용에 있어서 애를 먹을지도 모른다. 이 블로그에서도 &lt;a href=&quot;https://github.com/jekyll/jekyll-archives&quot;&gt;jekyll-archives&lt;/a&gt; 라는 플러그인을 적용시키는데에 애를 먹었기 때문에, 한 번 정리해 두려고 한다.&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;기본세팅&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://jekyllthemes.org&quot;&gt;jekyllthemes.org&lt;/a&gt;를 통해 원하는 테마를 선택하고, Fork까지 하는 과정은 생략하려 한다. 이와 관련된 내용은 다른 블로그를 참고해도 되고, 아주 간단하다. 내 GitHub 계정에 Fork하고, Setting에서 repository 이름을 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;내계정&amp;gt;.github.io &lt;/code&gt;로 설정하면 자동으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;https://&amp;lt;내계정&amp;gt;.github.io&lt;/code&gt;로 호스팅 된다. 하지만 만약 Fork한 테마에 외부 플러그인이 적용된 부분이 있다면, 그 부분은 작동하지 않는다.&lt;/p&gt;

&lt;p&gt;기본적인 Jekyll에 대한 지식이 부족한 상태에서는 &lt;a href=&quot;http://jekyllrb-ko.github.io/docs/home/&quot;&gt;Jekyll 공식 페이지&lt;/a&gt;를 참고하자.&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;외부플러그인 적용하기&lt;/h1&gt;
&lt;p&gt;외부 플러그인을 적용하기 위해서는 로컬에서 페이지들을 build하고, build된 페이지가 생성된 폴더를 root로하여 repository의 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 브랜치에 업로드 해야 한다. 아래와 같은 절차를 따르자.&lt;/p&gt;

&lt;h2 id=&quot;repository-source--&quot;&gt;Repository에 source 브랜치 생성&lt;/h2&gt;
&lt;p&gt;Repo에 &lt;code class=&quot;highlighter-rouge&quot;&gt;source&lt;/code&gt;라는 브랜치를 생성하자. &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 브랜치에는 빌드 된 리소스들이 들어가야 하기 때문에, 현재 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;에 존재하는 소스들이 복사될 브랜치이다.&lt;/p&gt;

&lt;pre&gt;
$ git checkout -b source master
$ git push -u origin source
&lt;/pre&gt;

&lt;p&gt;그리고나서 GitHub Setting 페이지에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;source&lt;/code&gt;브랜치를 default 브랜치로 바꿔주자. &lt;code class=&quot;highlighter-rouge&quot;&gt;Settings &amp;gt; Branches &amp;gt; Default branch&lt;/code&gt;에 있다.&lt;/p&gt;

&lt;h2 id=&quot;publishig--&quot;&gt;Publishig 자동화 하기&lt;/h2&gt;
&lt;p&gt;수동으로 빌드 된 페이지를 GitHub에 publishing하는 방법은 &lt;a href=&quot;http://gumpcha.github.io/blog/github-pages-with-jekyll-custom-plugin/&quot;&gt;여기&lt;/a&gt;에 잘 설명 되어있다. 허나 너무 번거롭다. 자동화 하자.&lt;/p&gt;

&lt;p&gt;로컬 Repo 루트에 &lt;code class=&quot;highlighter-rouge&quot;&gt;rakefile&lt;/code&gt; 이라는 파일을 하나 생성한다. 그리고 파일 내용은 아래와 같이 구성한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;rubygems&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;tmpdir&quot;&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;bundler/setup&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;jekyll&quot;&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;# Change your GitHub reponame&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;GITHUB_REPONAME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;eunvanz/eunvanz.github.io&quot;&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Generate blog files&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:generate&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;Jekyll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Site&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Jekyll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;source&quot;&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;destination&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;_site&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;})).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;process&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Generate and publish blog to gh-pages&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:publish&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:generate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;Dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;mktmpdir&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cp_r&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;_site/.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;pwd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pwd&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;Dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;chdir&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;

    &lt;span class=&quot;nb&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;git init&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;git add .&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Site updated at &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;utc&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;git commit -m &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;inspect&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;git remote add origin https://github.com/&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;GITHUB_REPONAME&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;.git&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;git push origin master --force&quot;&lt;/span&gt;

    &lt;span class=&quot;no&quot;&gt;Dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;chdir&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwd&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그리고 로컬 Repo Root 커맨드라인에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;로 로컬의&lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 폴더에 빌드를 하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;rake publish&lt;/code&gt;를 입력하기만 하면 자동으로 GitHub Pages에 배포된다.&lt;/p&gt;

&lt;p&gt;여러 방법을 찾아봤으나 이 방법이 가장 간단한 방법이다. 이후에는 로컬에서 소스를 관리하고, 빌드된 리소스만 커맨드입력을 통해 배포하면 된다. Ruby를 사용할 줄 몰라도 비교적 쉽게 따라할 수 있으니 헤매고 계신다면 이렇게 해보세요. 설명이 부족한 부분이 있다면 지적바랍니다.&lt;/p&gt;

</description>
        <pubDate>Mon, 29 Jan 2018 21:08:55 +0900</pubDate>
        <link>https://eunvanz.github.io/jekyll/2018/01/29/github-%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%97%90%EC%84%9C-Jekyll-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
        <guid isPermaLink="true">https://eunvanz.github.io/jekyll/2018/01/29/github-%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%97%90%EC%84%9C-Jekyll-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
        
        <category>jekyll</category>
        
        <category>github</category>
        
        <category>블로그</category>
        
        
        <category>jekyll</category>
        
      </item>
    
  </channel>
</rss>
